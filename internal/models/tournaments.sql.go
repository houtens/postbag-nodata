// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: tournaments.sql

package models

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createTournament = `-- name: CreateTournament :one

INSERT INTO tournaments (
    name,
    short_name,
    start_date,
    end_date,
    state,
    num_divisions,
    num_rounds,
    num_entries,
    is_pc,
    is_fc,
    is_rr,
    is_wespa,
    is_invitational,
    is_locked,
    creator_id,
    organiser_id,
    director_id,
    coperator_id,
    x_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15,
    $16, $17, $18, $19
) RETURNING id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at
`

type CreateTournamentParams struct {
	Name           string         `db:"name"`
	ShortName      sql.NullString `db:"short_name"`
	StartDate      sql.NullTime   `db:"start_date"`
	EndDate        sql.NullTime   `db:"end_date"`
	State          uuid.UUID      `db:"state"`
	NumDivisions   sql.NullInt32  `db:"num_divisions"`
	NumRounds      sql.NullInt32  `db:"num_rounds"`
	NumEntries     sql.NullInt32  `db:"num_entries"`
	IsPc           bool           `db:"is_pc"`
	IsFc           bool           `db:"is_fc"`
	IsRr           bool           `db:"is_rr"`
	IsWespa        bool           `db:"is_wespa"`
	IsInvitational bool           `db:"is_invitational"`
	IsLocked       bool           `db:"is_locked"`
	CreatorID      uuid.NullUUID  `db:"creator_id"`
	OrganiserID    uuid.NullUUID  `db:"organiser_id"`
	DirectorID     uuid.NullUUID  `db:"director_id"`
	CoperatorID    uuid.NullUUID  `db:"coperator_id"`
	XID            string         `db:"x_id"`
}

// #160 is_locked
func (q *Queries) CreateTournament(ctx context.Context, arg CreateTournamentParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, createTournament,
		arg.Name,
		arg.ShortName,
		arg.StartDate,
		arg.EndDate,
		arg.State,
		arg.NumDivisions,
		arg.NumRounds,
		arg.NumEntries,
		arg.IsPc,
		arg.IsFc,
		arg.IsRr,
		arg.IsWespa,
		arg.IsInvitational,
		arg.IsLocked,
		arg.CreatorID,
		arg.OrganiserID,
		arg.DirectorID,
		arg.CoperatorID,
		arg.XID,
	)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.StartDate,
		&i.EndDate,
		&i.State,
		&i.NumDivisions,
		&i.NumRounds,
		&i.NumEntries,
		&i.IsPc,
		&i.IsFc,
		&i.IsRr,
		&i.IsWespa,
		&i.IsInvitational,
		&i.IsLocked,
		&i.CreatorID,
		&i.OrganiserID,
		&i.DirectorID,
		&i.CoperatorID,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTournament = `-- name: DeleteTournament :exec
DELETE FROM tournaments
WHERE id = $1
`

func (q *Queries) DeleteTournament(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTournament, id)
	return err
}

const getTournament = `-- name: GetTournament :one
SELECT id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at FROM tournaments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTournament(ctx context.Context, id uuid.UUID) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, getTournament, id)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.StartDate,
		&i.EndDate,
		&i.State,
		&i.NumDivisions,
		&i.NumRounds,
		&i.NumEntries,
		&i.IsPc,
		&i.IsFc,
		&i.IsRr,
		&i.IsWespa,
		&i.IsInvitational,
		&i.IsLocked,
		&i.CreatorID,
		&i.OrganiserID,
		&i.DirectorID,
		&i.CoperatorID,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTournamentByXID = `-- name: GetTournamentByXID :one

SELECT id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at FROM tournaments
WHERE x_id = $1 LIMIT 1
`

// end crud
func (q *Queries) GetTournamentByXID(ctx context.Context, xID string) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, getTournamentByXID, xID)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.StartDate,
		&i.EndDate,
		&i.State,
		&i.NumDivisions,
		&i.NumRounds,
		&i.NumEntries,
		&i.IsPc,
		&i.IsFc,
		&i.IsRr,
		&i.IsWespa,
		&i.IsInvitational,
		&i.IsLocked,
		&i.CreatorID,
		&i.OrganiserID,
		&i.DirectorID,
		&i.CoperatorID,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRecentTournaments = `-- name: ListRecentTournaments :many
SELECT id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at FROM tournaments
WHERE is_locked = true
ORDER BY end_date desc
LIMIT $1
OFFSET $2
`

type ListRecentTournamentsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListRecentTournaments(ctx context.Context, arg ListRecentTournamentsParams) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, listRecentTournaments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.StartDate,
			&i.EndDate,
			&i.State,
			&i.NumDivisions,
			&i.NumRounds,
			&i.NumEntries,
			&i.IsPc,
			&i.IsFc,
			&i.IsRr,
			&i.IsWespa,
			&i.IsInvitational,
			&i.IsLocked,
			&i.CreatorID,
			&i.OrganiserID,
			&i.DirectorID,
			&i.CoperatorID,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentTournamentsForPlayer = `-- name: ListRecentTournamentsForPlayer :many
SELECT DISTINCT(t.name), t.start_date, t.end_date, t.num_rounds
FROM results r JOIN tournaments t ON r.tournament_id = t.id
WHERE t.is_locked = true 
AND (r.player1_id = $1 OR r.player2_id = $1) 
ORDER BY t.end_date DESC 
LIMIT 10
`

type ListRecentTournamentsForPlayerRow struct {
	Name      string        `db:"name"`
	StartDate sql.NullTime  `db:"start_date"`
	EndDate   sql.NullTime  `db:"end_date"`
	NumRounds sql.NullInt32 `db:"num_rounds"`
}

func (q *Queries) ListRecentTournamentsForPlayer(ctx context.Context, player1ID uuid.NullUUID) ([]ListRecentTournamentsForPlayerRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentTournamentsForPlayer, player1ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentTournamentsForPlayerRow{}
	for rows.Next() {
		var i ListRecentTournamentsForPlayerRow
		if err := rows.Scan(
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.NumRounds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournaments = `-- name: ListTournaments :many
SELECT id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at FROM tournaments
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListTournamentsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListTournaments(ctx context.Context, arg ListTournamentsParams) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, listTournaments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.StartDate,
			&i.EndDate,
			&i.State,
			&i.NumDivisions,
			&i.NumRounds,
			&i.NumEntries,
			&i.IsPc,
			&i.IsFc,
			&i.IsRr,
			&i.IsWespa,
			&i.IsInvitational,
			&i.IsLocked,
			&i.CreatorID,
			&i.OrganiserID,
			&i.DirectorID,
			&i.CoperatorID,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingTournaments = `-- name: ListUpcomingTournaments :many
SELECT id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at FROM tournaments
WHERE is_locked = false
ORDER BY start_date asc
`

func (q *Queries) ListUpcomingTournaments(ctx context.Context) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, listUpcomingTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.StartDate,
			&i.EndDate,
			&i.State,
			&i.NumDivisions,
			&i.NumRounds,
			&i.NumEntries,
			&i.IsPc,
			&i.IsFc,
			&i.IsRr,
			&i.IsWespa,
			&i.IsInvitational,
			&i.IsLocked,
			&i.CreatorID,
			&i.OrganiserID,
			&i.DirectorID,
			&i.CoperatorID,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingTournamentsForPlayer = `-- name: ListUpcomingTournamentsForPlayer :many
SELECT DISTINCT(t.name), t.start_date, t.end_date, t.num_rounds
FROM ratings r JOIN tournaments t ON r.tournament_id = t.id
WHERE r.is_locked = false AND r.user_id = $1 ORDER BY t.end_date ASC
`

type ListUpcomingTournamentsForPlayerRow struct {
	Name      string        `db:"name"`
	StartDate sql.NullTime  `db:"start_date"`
	EndDate   sql.NullTime  `db:"end_date"`
	NumRounds sql.NullInt32 `db:"num_rounds"`
}

func (q *Queries) ListUpcomingTournamentsForPlayer(ctx context.Context, userID uuid.UUID) ([]ListUpcomingTournamentsForPlayerRow, error) {
	rows, err := q.db.QueryContext(ctx, listUpcomingTournamentsForPlayer, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUpcomingTournamentsForPlayerRow{}
	for rows.Next() {
		var i ListUpcomingTournamentsForPlayerRow
		if err := rows.Scan(
			&i.Name,
			&i.StartDate,
			&i.EndDate,
			&i.NumRounds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateTournaments = `-- name: TruncateTournaments :exec
truncate tournaments cascade
`

func (q *Queries) TruncateTournaments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateTournaments)
	return err
}

const updateTournament = `-- name: UpdateTournament :one
UPDATE tournaments
SET
    name = $2, 
    short_name = $3,
    start_date = $4,
    end_date = $5,
    state = $6,
    num_divisions = $7,
    num_rounds = $8,
    num_entries = $9,
    is_pc = $10,
    is_fc = $11,
    is_rr = $12,
    is_wespa = $13,
    is_invitational = $14,
    is_locked = $15,
    creator_id = $16,
    organiser_id = $17,
    director_id = $18,
    coperator_id = $19,
    x_id = $20
WHERE id = $1
RETURNING id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at
`

type UpdateTournamentParams struct {
	ID             uuid.UUID      `db:"id"`
	Name           string         `db:"name"`
	ShortName      sql.NullString `db:"short_name"`
	StartDate      sql.NullTime   `db:"start_date"`
	EndDate        sql.NullTime   `db:"end_date"`
	State          uuid.UUID      `db:"state"`
	NumDivisions   sql.NullInt32  `db:"num_divisions"`
	NumRounds      sql.NullInt32  `db:"num_rounds"`
	NumEntries     sql.NullInt32  `db:"num_entries"`
	IsPc           bool           `db:"is_pc"`
	IsFc           bool           `db:"is_fc"`
	IsRr           bool           `db:"is_rr"`
	IsWespa        bool           `db:"is_wespa"`
	IsInvitational bool           `db:"is_invitational"`
	IsLocked       bool           `db:"is_locked"`
	CreatorID      uuid.NullUUID  `db:"creator_id"`
	OrganiserID    uuid.NullUUID  `db:"organiser_id"`
	DirectorID     uuid.NullUUID  `db:"director_id"`
	CoperatorID    uuid.NullUUID  `db:"coperator_id"`
	XID            string         `db:"x_id"`
}

func (q *Queries) UpdateTournament(ctx context.Context, arg UpdateTournamentParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, updateTournament,
		arg.ID,
		arg.Name,
		arg.ShortName,
		arg.StartDate,
		arg.EndDate,
		arg.State,
		arg.NumDivisions,
		arg.NumRounds,
		arg.NumEntries,
		arg.IsPc,
		arg.IsFc,
		arg.IsRr,
		arg.IsWespa,
		arg.IsInvitational,
		arg.IsLocked,
		arg.CreatorID,
		arg.OrganiserID,
		arg.DirectorID,
		arg.CoperatorID,
		arg.XID,
	)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.StartDate,
		&i.EndDate,
		&i.State,
		&i.NumDivisions,
		&i.NumRounds,
		&i.NumEntries,
		&i.IsPc,
		&i.IsFc,
		&i.IsRr,
		&i.IsWespa,
		&i.IsInvitational,
		&i.IsLocked,
		&i.CreatorID,
		&i.OrganiserID,
		&i.DirectorID,
		&i.CoperatorID,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTournamentEntries = `-- name: UpdateTournamentEntries :one
update tournaments set num_entries = $2 where id = $1 returning id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at
`

type UpdateTournamentEntriesParams struct {
	ID         uuid.UUID     `db:"id"`
	NumEntries sql.NullInt32 `db:"num_entries"`
}

func (q *Queries) UpdateTournamentEntries(ctx context.Context, arg UpdateTournamentEntriesParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentEntries, arg.ID, arg.NumEntries)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.StartDate,
		&i.EndDate,
		&i.State,
		&i.NumDivisions,
		&i.NumRounds,
		&i.NumEntries,
		&i.IsPc,
		&i.IsFc,
		&i.IsRr,
		&i.IsWespa,
		&i.IsInvitational,
		&i.IsLocked,
		&i.CreatorID,
		&i.OrganiserID,
		&i.DirectorID,
		&i.CoperatorID,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTournamentRoundsDivisions = `-- name: UpdateTournamentRoundsDivisions :one
update tournaments set num_rounds = $2, num_divisions = $3 where id = $1 returning id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, is_locked, creator_id, organiser_id, director_id, coperator_id, x_id, created_at, updated_at
`

type UpdateTournamentRoundsDivisionsParams struct {
	ID           uuid.UUID     `db:"id"`
	NumRounds    sql.NullInt32 `db:"num_rounds"`
	NumDivisions sql.NullInt32 `db:"num_divisions"`
}

func (q *Queries) UpdateTournamentRoundsDivisions(ctx context.Context, arg UpdateTournamentRoundsDivisionsParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentRoundsDivisions, arg.ID, arg.NumRounds, arg.NumDivisions)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ShortName,
		&i.StartDate,
		&i.EndDate,
		&i.State,
		&i.NumDivisions,
		&i.NumRounds,
		&i.NumEntries,
		&i.IsPc,
		&i.IsFc,
		&i.IsRr,
		&i.IsWespa,
		&i.IsInvitational,
		&i.IsLocked,
		&i.CreatorID,
		&i.OrganiserID,
		&i.DirectorID,
		&i.CoperatorID,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
