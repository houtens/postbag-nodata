// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: results.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const createResult = `-- name: CreateResult :one

INSERT INTO results (
    player1_id,
    player2_id,
    score1,
    score2,
    spread,
    tournament_id,
    type,
    round_num,
    is_locked,
    x_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, player1_id, player2_id, score1, score2, spread, tournament_id, round_num, type, is_locked, x_id, created_at, updated_at
`

type CreateResultParams struct {
	Player1ID    uuid.NullUUID `db:"player1_id"`
	Player2ID    uuid.NullUUID `db:"player2_id"`
	Score1       int32         `db:"score1"`
	Score2       int32         `db:"score2"`
	Spread       int32         `db:"spread"`
	TournamentID uuid.UUID     `db:"tournament_id"`
	Type         int32         `db:"type"`
	RoundNum     int32         `db:"round_num"`
	IsLocked     bool          `db:"is_locked"`
	XID          string        `db:"x_id"`
}

// #160 is_locked
func (q *Queries) CreateResult(ctx context.Context, arg CreateResultParams) (Result, error) {
	row := q.db.QueryRowContext(ctx, createResult,
		arg.Player1ID,
		arg.Player2ID,
		arg.Score1,
		arg.Score2,
		arg.Spread,
		arg.TournamentID,
		arg.Type,
		arg.RoundNum,
		arg.IsLocked,
		arg.XID,
	)
	var i Result
	err := row.Scan(
		&i.ID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Score1,
		&i.Score2,
		&i.Spread,
		&i.TournamentID,
		&i.RoundNum,
		&i.Type,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteResult = `-- name: DeleteResult :exec
DELETE FROM results
where id = $1
`

func (q *Queries) DeleteResult(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteResult, id)
	return err
}

const getAverageScores = `-- name: GetAverageScores :one
SELECT ROUND(AVG(s.score1)) AS for, ROUND(AVG(s.score2)) AS against FROM
(SELECT score1, score2
  FROM results
  WHERE results.player1_id = $1 AND type = 1 AND is_locked = true
  UNION ALL
  SELECT score2, score1 FROM results
  WHERE player2_id = $1 AND type = 1 AND is_locked = true
) AS s
`

type GetAverageScoresRow struct {
	For     float64 `db:"for"`
	Against float64 `db:"against"`
}

func (q *Queries) GetAverageScores(ctx context.Context, player1ID uuid.NullUUID) (GetAverageScoresRow, error) {
	row := q.db.QueryRowContext(ctx, getAverageScores, player1ID)
	var i GetAverageScoresRow
	err := row.Scan(&i.For, &i.Against)
	return i, err
}

const getResult = `-- name: GetResult :one
SELECT id, player1_id, player2_id, score1, score2, spread, tournament_id, round_num, type, is_locked, x_id, created_at, updated_at FROM results
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetResult(ctx context.Context, id uuid.UUID) (Result, error) {
	row := q.db.QueryRowContext(ctx, getResult, id)
	var i Result
	err := row.Scan(
		&i.ID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Score1,
		&i.Score2,
		&i.Spread,
		&i.TournamentID,
		&i.RoundNum,
		&i.Type,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResultByXID = `-- name: GetResultByXID :one
SELECT id, player1_id, player2_id, score1, score2, spread, tournament_id, round_num, type, is_locked, x_id, created_at, updated_at FROM results
WHERE x_id = $1 LIMIT 1
`

func (q *Queries) GetResultByXID(ctx context.Context, xID string) (Result, error) {
	row := q.db.QueryRowContext(ctx, getResultByXID, xID)
	var i Result
	err := row.Scan(
		&i.ID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Score1,
		&i.Score2,
		&i.Spread,
		&i.TournamentID,
		&i.RoundNum,
		&i.Type,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWinLossDraw = `-- name: GetWinLossDraw :one
SELECT
  SUM(CASE WHEN r.score1 > r.score2 THEN 1 ELSE 0 END) as won,
  SUM(CASE WHEN r.score1 < r.score2 THEN 1 ELSE 0 END) as lost,
  SUM(CASE WHEN r.score1 = r.score2 THEN 1 ELSE 0 END) as drawn
FROM (
    SELECT player1_id, score1, score2, type FROM results WHERE results.player1_id = $1 AND is_locked = true
    UNION ALL
    SELECT player2_id, score2, score1, type FROM results WHERE player2_id = $1 AND is_locked = true
) AS r LIMIT 1
`

type GetWinLossDrawRow struct {
	Won   int64 `db:"won"`
	Lost  int64 `db:"lost"`
	Drawn int64 `db:"drawn"`
}

func (q *Queries) GetWinLossDraw(ctx context.Context, player1ID uuid.NullUUID) (GetWinLossDrawRow, error) {
	row := q.db.QueryRowContext(ctx, getWinLossDraw, player1ID)
	var i GetWinLossDrawRow
	err := row.Scan(&i.Won, &i.Lost, &i.Drawn)
	return i, err
}

const getWinsByUserTournament = `-- name: GetWinsByUserTournament :one
SELECT SUM(CASE WHEN score1 > score2 THEN 1 WHEN score1 = score2 THEN 0.5 ELSE 0 END)::float wins FROM (
    SELECT score1, score2 FROM results WHERE results.tournament_id = $1 AND results.player1_id = $2
    UNION ALL
    SELECT score2, score1 FROM results WHERE tournament_id = $1 AND player2_id = $2) AS x LIMIT 1
`

type GetWinsByUserTournamentParams struct {
	TournamentID uuid.UUID     `db:"tournament_id"`
	Player1ID    uuid.NullUUID `db:"player1_id"`
}

func (q *Queries) GetWinsByUserTournament(ctx context.Context, arg GetWinsByUserTournamentParams) (float64, error) {
	row := q.db.QueryRowContext(ctx, getWinsByUserTournament, arg.TournamentID, arg.Player1ID)
	var wins float64
	err := row.Scan(&wins)
	return wins, err
}

const listResults = `-- name: ListResults :many
SELECT id, player1_id, player2_id, score1, score2, spread, tournament_id, round_num, type, is_locked, x_id, created_at, updated_at FROM results
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListResultsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListResults(ctx context.Context, arg ListResultsParams) ([]Result, error) {
	rows, err := q.db.QueryContext(ctx, listResults, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Result{}
	for rows.Next() {
		var i Result
		if err := rows.Scan(
			&i.ID,
			&i.Player1ID,
			&i.Player2ID,
			&i.Score1,
			&i.Score2,
			&i.Spread,
			&i.TournamentID,
			&i.RoundNum,
			&i.Type,
			&i.IsLocked,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateResults = `-- name: TruncateResults :exec
truncate results cascade
`

func (q *Queries) TruncateResults(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateResults)
	return err
}

const updateResult = `-- name: UpdateResult :one
UPDATE results
SET
player1_id = $2,
player2_id = $3,
score1 = $4,
score2 = $5,
spread = $6,
tournament_id = $7,
type = $8,
round_num = $9,
is_locked = $10,
x_id = $11
WHERE id = $1
RETURNING id, player1_id, player2_id, score1, score2, spread, tournament_id, round_num, type, is_locked, x_id, created_at, updated_at
`

type UpdateResultParams struct {
	ID           uuid.UUID     `db:"id"`
	Player1ID    uuid.NullUUID `db:"player1_id"`
	Player2ID    uuid.NullUUID `db:"player2_id"`
	Score1       int32         `db:"score1"`
	Score2       int32         `db:"score2"`
	Spread       int32         `db:"spread"`
	TournamentID uuid.UUID     `db:"tournament_id"`
	Type         int32         `db:"type"`
	RoundNum     int32         `db:"round_num"`
	IsLocked     bool          `db:"is_locked"`
	XID          string        `db:"x_id"`
}

func (q *Queries) UpdateResult(ctx context.Context, arg UpdateResultParams) (Result, error) {
	row := q.db.QueryRowContext(ctx, updateResult,
		arg.ID,
		arg.Player1ID,
		arg.Player2ID,
		arg.Score1,
		arg.Score2,
		arg.Spread,
		arg.TournamentID,
		arg.Type,
		arg.RoundNum,
		arg.IsLocked,
		arg.XID,
	)
	var i Result
	err := row.Scan(
		&i.ID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Score1,
		&i.Score2,
		&i.Spread,
		&i.TournamentID,
		&i.RoundNum,
		&i.Type,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
