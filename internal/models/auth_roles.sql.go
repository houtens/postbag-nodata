// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: auth_roles.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const createAuthRole = `-- name: CreateAuthRole :one
 INSERT INTO auth_roles (
    name,
    can_login,
    is_guest,
    is_members_admin,
    is_clubs_admin,
    is_ratings_admin,
    is_tournaments_admin,
    is_super_admin
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, can_login, is_guest, is_members_admin, is_clubs_admin, is_ratings_admin, is_tournaments_admin, is_super_admin, created_at, updated_at
`

type CreateAuthRoleParams struct {
	Name               string `db:"name"`
	CanLogin           bool   `db:"can_login"`
	IsGuest            bool   `db:"is_guest"`
	IsMembersAdmin     bool   `db:"is_members_admin"`
	IsClubsAdmin       bool   `db:"is_clubs_admin"`
	IsRatingsAdmin     bool   `db:"is_ratings_admin"`
	IsTournamentsAdmin bool   `db:"is_tournaments_admin"`
	IsSuperAdmin       bool   `db:"is_super_admin"`
}

func (q *Queries) CreateAuthRole(ctx context.Context, arg CreateAuthRoleParams) (AuthRole, error) {
	row := q.db.QueryRowContext(ctx, createAuthRole,
		arg.Name,
		arg.CanLogin,
		arg.IsGuest,
		arg.IsMembersAdmin,
		arg.IsClubsAdmin,
		arg.IsRatingsAdmin,
		arg.IsTournamentsAdmin,
		arg.IsSuperAdmin,
	)
	var i AuthRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CanLogin,
		&i.IsGuest,
		&i.IsMembersAdmin,
		&i.IsClubsAdmin,
		&i.IsRatingsAdmin,
		&i.IsTournamentsAdmin,
		&i.IsSuperAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAuthRole = `-- name: DeleteAuthRole :exec
DELETE FROM auth_roles
WHERE id = $1
`

func (q *Queries) DeleteAuthRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAuthRole, id)
	return err
}

const getAuthRole = `-- name: GetAuthRole :one
SELECT id, name, can_login, is_guest, is_members_admin, is_clubs_admin, is_ratings_admin, is_tournaments_admin, is_super_admin, created_at, updated_at FROM auth_roles
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAuthRole(ctx context.Context, id uuid.UUID) (AuthRole, error) {
	row := q.db.QueryRowContext(ctx, getAuthRole, id)
	var i AuthRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CanLogin,
		&i.IsGuest,
		&i.IsMembersAdmin,
		&i.IsClubsAdmin,
		&i.IsRatingsAdmin,
		&i.IsTournamentsAdmin,
		&i.IsSuperAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAuthRoles = `-- name: ListAuthRoles :many
SELECT id, name, can_login, is_guest, is_members_admin, is_clubs_admin, is_ratings_admin, is_tournaments_admin, is_super_admin, created_at, updated_at FROM auth_roles
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListAuthRolesParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListAuthRoles(ctx context.Context, arg ListAuthRolesParams) ([]AuthRole, error) {
	rows, err := q.db.QueryContext(ctx, listAuthRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthRole{}
	for rows.Next() {
		var i AuthRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CanLogin,
			&i.IsGuest,
			&i.IsMembersAdmin,
			&i.IsClubsAdmin,
			&i.IsRatingsAdmin,
			&i.IsTournamentsAdmin,
			&i.IsSuperAdmin,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateAuthRole = `-- name: TruncateAuthRole :exec
truncate auth_roles cascade
`

func (q *Queries) TruncateAuthRole(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateAuthRole)
	return err
}

const updateAuthRole = `-- name: UpdateAuthRole :one
UPDATE auth_roles
SET
name = $2,
can_login = $3,
is_guest = $4,
is_members_admin = $5,
is_clubs_admin = $6,
is_ratings_admin = $7,
is_tournaments_admin = $8,
is_super_admin = $9
WHERE id = $1 RETURNING id, name, can_login, is_guest, is_members_admin, is_clubs_admin, is_ratings_admin, is_tournaments_admin, is_super_admin, created_at, updated_at
`

type UpdateAuthRoleParams struct {
	ID                 uuid.UUID `db:"id"`
	Name               string    `db:"name"`
	CanLogin           bool      `db:"can_login"`
	IsGuest            bool      `db:"is_guest"`
	IsMembersAdmin     bool      `db:"is_members_admin"`
	IsClubsAdmin       bool      `db:"is_clubs_admin"`
	IsRatingsAdmin     bool      `db:"is_ratings_admin"`
	IsTournamentsAdmin bool      `db:"is_tournaments_admin"`
	IsSuperAdmin       bool      `db:"is_super_admin"`
}

func (q *Queries) UpdateAuthRole(ctx context.Context, arg UpdateAuthRoleParams) (AuthRole, error) {
	row := q.db.QueryRowContext(ctx, updateAuthRole,
		arg.ID,
		arg.Name,
		arg.CanLogin,
		arg.IsGuest,
		arg.IsMembersAdmin,
		arg.IsClubsAdmin,
		arg.IsRatingsAdmin,
		arg.IsTournamentsAdmin,
		arg.IsSuperAdmin,
	)
	var i AuthRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CanLogin,
		&i.IsGuest,
		&i.IsMembersAdmin,
		&i.IsClubsAdmin,
		&i.IsRatingsAdmin,
		&i.IsTournamentsAdmin,
		&i.IsSuperAdmin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
