// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: ratings.sql

package models

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRating = `-- name: CreateRating :one

INSERT INTO ratings (
    user_id,
    tournament_id,
    division,
    num_games,
    start_rating,
    end_rating,
    rating_points,
    opp_ratings_sum,
    num_wins,
    is_locked,
    x_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, x_id, created_at, updated_at
`

type CreateRatingParams struct {
	UserID        uuid.UUID     `db:"user_id"`
	TournamentID  uuid.UUID     `db:"tournament_id"`
	Division      int32         `db:"division"`
	NumGames      sql.NullInt32 `db:"num_games"`
	StartRating   sql.NullInt32 `db:"start_rating"`
	EndRating     sql.NullInt32 `db:"end_rating"`
	RatingPoints  sql.NullInt32 `db:"rating_points"`
	OppRatingsSum sql.NullInt32 `db:"opp_ratings_sum"`
	NumWins       float32       `db:"num_wins"`
	IsLocked      bool          `db:"is_locked"`
	XID           string        `db:"x_id"`
}

// #160 is_locked
func (q *Queries) CreateRating(ctx context.Context, arg CreateRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, createRating,
		arg.UserID,
		arg.TournamentID,
		arg.Division,
		arg.NumGames,
		arg.StartRating,
		arg.EndRating,
		arg.RatingPoints,
		arg.OppRatingsSum,
		arg.NumWins,
		arg.IsLocked,
		arg.XID,
	)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TournamentID,
		&i.Division,
		&i.NumGames,
		&i.StartRating,
		&i.EndRating,
		&i.RatingPoints,
		&i.OppRatingsSum,
		&i.NumWins,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRating = `-- name: DeleteRating :exec
DELETE FROM ratings WHERE id = $1
`

func (q *Queries) DeleteRating(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRating, id)
	return err
}

const getCountPlayersInTournament = `-- name: GetCountPlayersInTournament :one
select count(distinct user_id) from ratings where tournament_id = $1 limit 1
`

func (q *Queries) GetCountPlayersInTournament(ctx context.Context, tournamentID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCountPlayersInTournament, tournamentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestRating = `-- name: GetLatestRating :one
SELECT end_rating FROM ratings r join tournaments t on r.tournament_id = t.id 
WHERE r.user_id = $1 AND t.is_locked = true ORDER BY t.end_date DESC LIMIT 1
`

func (q *Queries) GetLatestRating(ctx context.Context, userID uuid.UUID) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getLatestRating, userID)
	var end_rating sql.NullInt32
	err := row.Scan(&end_rating)
	return end_rating, err
}

const getRating = `-- name: GetRating :one
SELECT id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, x_id, created_at, updated_at FROM ratings WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRating(ctx context.Context, id uuid.UUID) (Rating, error) {
	row := q.db.QueryRowContext(ctx, getRating, id)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TournamentID,
		&i.Division,
		&i.NumGames,
		&i.StartRating,
		&i.EndRating,
		&i.RatingPoints,
		&i.OppRatingsSum,
		&i.NumWins,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingByXID = `-- name: GetRatingByXID :one

SELECT id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, x_id, created_at, updated_at FROM ratings WHERE x_id = $1 LIMIT 1
`

// end CRUD
func (q *Queries) GetRatingByXID(ctx context.Context, xID string) (Rating, error) {
	row := q.db.QueryRowContext(ctx, getRatingByXID, xID)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TournamentID,
		&i.Division,
		&i.NumGames,
		&i.StartRating,
		&i.EndRating,
		&i.RatingPoints,
		&i.OppRatingsSum,
		&i.NumWins,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRatingsTournamentMetadata = `-- name: GetRatingsTournamentMetadata :one


select max(coalesce(division, 0)) divisions, max(coalesce(num_games, 0)) rounds from ratings where tournament_id = $1 and is_locked = 't' limit 1
`

type GetRatingsTournamentMetadataRow struct {
	Divisions interface{} `db:"divisions"`
	Rounds    interface{} `db:"rounds"`
}

// mr: max_ratings
func (q *Queries) GetRatingsTournamentMetadata(ctx context.Context, tournamentID uuid.UUID) (GetRatingsTournamentMetadataRow, error) {
	row := q.db.QueryRowContext(ctx, getRatingsTournamentMetadata, tournamentID)
	var i GetRatingsTournamentMetadataRow
	err := row.Scan(&i.Divisions, &i.Rounds)
	return i, err
}

const listRatings = `-- name: ListRatings :many
SELECT id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, x_id, created_at, updated_at FROM ratings
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListRatingsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

func (q *Queries) ListRatings(ctx context.Context, arg ListRatingsParams) ([]Rating, error) {
	rows, err := q.db.QueryContext(ctx, listRatings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rating{}
	for rows.Next() {
		var i Rating
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TournamentID,
			&i.Division,
			&i.NumGames,
			&i.StartRating,
			&i.EndRating,
			&i.RatingPoints,
			&i.OppRatingsSum,
			&i.NumWins,
			&i.IsLocked,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsByUser = `-- name: ListRatingsByUser :many
SELECT r.id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, r.is_locked, r.x_id, r.created_at, r.updated_at, t.id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, t.is_locked, creator_id, organiser_id, director_id, coperator_id, t.x_id, t.created_at, t.updated_at FROM 
    ratings r JOIN tournaments t 
ON r.tournament_id = t.id
WHERE r.user_id = $1 
AND r.is_locked = 't'
ORDER BY t.end_date
`

type ListRatingsByUserRow struct {
	ID             uuid.UUID      `db:"id"`
	UserID         uuid.UUID      `db:"user_id"`
	TournamentID   uuid.UUID      `db:"tournament_id"`
	Division       int32          `db:"division"`
	NumGames       sql.NullInt32  `db:"num_games"`
	StartRating    sql.NullInt32  `db:"start_rating"`
	EndRating      sql.NullInt32  `db:"end_rating"`
	RatingPoints   sql.NullInt32  `db:"rating_points"`
	OppRatingsSum  sql.NullInt32  `db:"opp_ratings_sum"`
	NumWins        float32        `db:"num_wins"`
	IsLocked       bool           `db:"is_locked"`
	XID            string         `db:"x_id"`
	CreatedAt      time.Time      `db:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at"`
	ID_2           uuid.UUID      `db:"id_2"`
	Name           string         `db:"name"`
	ShortName      sql.NullString `db:"short_name"`
	StartDate      sql.NullTime   `db:"start_date"`
	EndDate        sql.NullTime   `db:"end_date"`
	State          uuid.UUID      `db:"state"`
	NumDivisions   sql.NullInt32  `db:"num_divisions"`
	NumRounds      sql.NullInt32  `db:"num_rounds"`
	NumEntries     sql.NullInt32  `db:"num_entries"`
	IsPc           bool           `db:"is_pc"`
	IsFc           bool           `db:"is_fc"`
	IsRr           bool           `db:"is_rr"`
	IsWespa        bool           `db:"is_wespa"`
	IsInvitational bool           `db:"is_invitational"`
	IsLocked_2     bool           `db:"is_locked_2"`
	CreatorID      uuid.NullUUID  `db:"creator_id"`
	OrganiserID    uuid.NullUUID  `db:"organiser_id"`
	DirectorID     uuid.NullUUID  `db:"director_id"`
	CoperatorID    uuid.NullUUID  `db:"coperator_id"`
	XID_2          string         `db:"x_id_2"`
	CreatedAt_2    time.Time      `db:"created_at_2"`
	UpdatedAt_2    time.Time      `db:"updated_at_2"`
}

func (q *Queries) ListRatingsByUser(ctx context.Context, userID uuid.UUID) ([]ListRatingsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listRatingsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsByUserRow{}
	for rows.Next() {
		var i ListRatingsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TournamentID,
			&i.Division,
			&i.NumGames,
			&i.StartRating,
			&i.EndRating,
			&i.RatingPoints,
			&i.OppRatingsSum,
			&i.NumWins,
			&i.IsLocked,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.ShortName,
			&i.StartDate,
			&i.EndDate,
			&i.State,
			&i.NumDivisions,
			&i.NumRounds,
			&i.NumEntries,
			&i.IsPc,
			&i.IsFc,
			&i.IsRr,
			&i.IsWespa,
			&i.IsInvitational,
			&i.IsLocked_2,
			&i.CreatorID,
			&i.OrganiserID,
			&i.DirectorID,
			&i.CoperatorID,
			&i.XID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsByUserRev = `-- name: ListRatingsByUserRev :many
SELECT r.id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, r.is_locked, r.x_id, r.created_at, r.updated_at, t.id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, t.is_locked, creator_id, organiser_id, director_id, coperator_id, t.x_id, t.created_at, t.updated_at FROM 
    ratings r JOIN tournaments t 
ON r.tournament_id = t.id
WHERE r.user_id = $1 
AND r.is_locked = 't'
ORDER BY t.end_date desc
`

type ListRatingsByUserRevRow struct {
	ID             uuid.UUID      `db:"id"`
	UserID         uuid.UUID      `db:"user_id"`
	TournamentID   uuid.UUID      `db:"tournament_id"`
	Division       int32          `db:"division"`
	NumGames       sql.NullInt32  `db:"num_games"`
	StartRating    sql.NullInt32  `db:"start_rating"`
	EndRating      sql.NullInt32  `db:"end_rating"`
	RatingPoints   sql.NullInt32  `db:"rating_points"`
	OppRatingsSum  sql.NullInt32  `db:"opp_ratings_sum"`
	NumWins        float32        `db:"num_wins"`
	IsLocked       bool           `db:"is_locked"`
	XID            string         `db:"x_id"`
	CreatedAt      time.Time      `db:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at"`
	ID_2           uuid.UUID      `db:"id_2"`
	Name           string         `db:"name"`
	ShortName      sql.NullString `db:"short_name"`
	StartDate      sql.NullTime   `db:"start_date"`
	EndDate        sql.NullTime   `db:"end_date"`
	State          uuid.UUID      `db:"state"`
	NumDivisions   sql.NullInt32  `db:"num_divisions"`
	NumRounds      sql.NullInt32  `db:"num_rounds"`
	NumEntries     sql.NullInt32  `db:"num_entries"`
	IsPc           bool           `db:"is_pc"`
	IsFc           bool           `db:"is_fc"`
	IsRr           bool           `db:"is_rr"`
	IsWespa        bool           `db:"is_wespa"`
	IsInvitational bool           `db:"is_invitational"`
	IsLocked_2     bool           `db:"is_locked_2"`
	CreatorID      uuid.NullUUID  `db:"creator_id"`
	OrganiserID    uuid.NullUUID  `db:"organiser_id"`
	DirectorID     uuid.NullUUID  `db:"director_id"`
	CoperatorID    uuid.NullUUID  `db:"coperator_id"`
	XID_2          string         `db:"x_id_2"`
	CreatedAt_2    time.Time      `db:"created_at_2"`
	UpdatedAt_2    time.Time      `db:"updated_at_2"`
}

func (q *Queries) ListRatingsByUserRev(ctx context.Context, userID uuid.UUID) ([]ListRatingsByUserRevRow, error) {
	rows, err := q.db.QueryContext(ctx, listRatingsByUserRev, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsByUserRevRow{}
	for rows.Next() {
		var i ListRatingsByUserRevRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TournamentID,
			&i.Division,
			&i.NumGames,
			&i.StartRating,
			&i.EndRating,
			&i.RatingPoints,
			&i.OppRatingsSum,
			&i.NumWins,
			&i.IsLocked,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.ShortName,
			&i.StartDate,
			&i.EndDate,
			&i.State,
			&i.NumDivisions,
			&i.NumRounds,
			&i.NumEntries,
			&i.IsPc,
			&i.IsFc,
			&i.IsRr,
			&i.IsWespa,
			&i.IsInvitational,
			&i.IsLocked_2,
			&i.CreatorID,
			&i.OrganiserID,
			&i.DirectorID,
			&i.CoperatorID,
			&i.XID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsForClub = `-- name: ListRatingsForClub :many
SELECT u.id, u.first_name, u.last_name, tt.name as title, mr.user_id, mr.end_rating
FROM (
  SELECT DISTINCT ON (r.user_id) user_id, r.end_rating, t.end_date 
  FROM ratings r JOIN tournaments t ON r.tournament_id = t.id 
  WHERE (t.is_locked = true and r.is_locked = true) 
  ORDER BY user_id, t.end_date DESC
) mr JOIN users u ON mr.user_id = u.id 
JOIN titles tt on tt.id = u.title_id
WHERE club_id = $1
ORDER BY end_rating DESC
LIMIT $2
OFFSET $3
`

type ListRatingsForClubParams struct {
	ClubID uuid.NullUUID `db:"club_id"`
	Limit  int32         `db:"limit"`
	Offset int32         `db:"offset"`
}

type ListRatingsForClubRow struct {
	ID        uuid.UUID     `db:"id"`
	FirstName string        `db:"first_name"`
	LastName  string        `db:"last_name"`
	Title     string        `db:"title"`
	UserID    uuid.UUID     `db:"user_id"`
	EndRating sql.NullInt32 `db:"end_rating"`
}

func (q *Queries) ListRatingsForClub(ctx context.Context, arg ListRatingsForClubParams) ([]ListRatingsForClubRow, error) {
	rows, err := q.db.QueryContext(ctx, listRatingsForClub, arg.ClubID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsForClubRow{}
	for rows.Next() {
		var i ListRatingsForClubRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Title,
			&i.UserID,
			&i.EndRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsRank = `-- name: ListRatingsRank :many
SELECT row_number() over(ORDER BY end_rating DESC), first_name, last_name, titles.name as title, clubs.name as club, max_ratings.user_id, end_rating, end_date, countries.name
FROM (
  SELECT DISTINCT ON (r.user_id) user_id, r.end_rating, t.end_date
  FROM ratings r JOIN tournaments t ON r.tournament_id = t.id
  WHERE (t.is_locked = true and r.is_locked = true)
  ORDER BY user_id, t.end_date DESC
) max_ratings JOIN users ON max_ratings.user_id = users.id
JOIN titles on users.title_id = titles.id
LEFT OUTER JOIN contacts on users.id = contacts.user_id
LEFT OUTER JOIN countries on contacts.country_id = countries.id
LEFT OUTER JOIN clubs on users.club_id = clubs.id
WHERE end_date > '2022-01-01' ORDER BY end_rating DESC 
LIMIT $1
OFFSET $2
`

type ListRatingsRankParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListRatingsRankRow struct {
	RowNumber int64          `db:"row_number"`
	FirstName string         `db:"first_name"`
	LastName  string         `db:"last_name"`
	Title     string         `db:"title"`
	Club      sql.NullString `db:"club"`
	UserID    uuid.UUID      `db:"user_id"`
	EndRating sql.NullInt32  `db:"end_rating"`
	EndDate   sql.NullTime   `db:"end_date"`
	Name      sql.NullString `db:"name"`
}

func (q *Queries) ListRatingsRank(ctx context.Context, arg ListRatingsRankParams) ([]ListRatingsRankRow, error) {
	rows, err := q.db.QueryContext(ctx, listRatingsRank, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsRankRow{}
	for rows.Next() {
		var i ListRatingsRankRow
		if err := rows.Scan(
			&i.RowNumber,
			&i.FirstName,
			&i.LastName,
			&i.Title,
			&i.Club,
			&i.UserID,
			&i.EndRating,
			&i.EndDate,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRatingsTournaments = `-- name: ListRatingsTournaments :many
SELECT r.id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, r.is_locked, r.x_id, r.created_at, r.updated_at, t.id, name, short_name, start_date, end_date, state, num_divisions, num_rounds, num_entries, is_pc, is_fc, is_rr, is_wespa, is_invitational, t.is_locked, creator_id, organiser_id, director_id, coperator_id, t.x_id, t.created_at, t.updated_at FROM
    ratings r JOIN tournaments t
ON r.tournament_id = t.id
ORDER BY r.id
LIMIT $1
OFFSET $2
`

type ListRatingsTournamentsParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListRatingsTournamentsRow struct {
	ID             uuid.UUID      `db:"id"`
	UserID         uuid.UUID      `db:"user_id"`
	TournamentID   uuid.UUID      `db:"tournament_id"`
	Division       int32          `db:"division"`
	NumGames       sql.NullInt32  `db:"num_games"`
	StartRating    sql.NullInt32  `db:"start_rating"`
	EndRating      sql.NullInt32  `db:"end_rating"`
	RatingPoints   sql.NullInt32  `db:"rating_points"`
	OppRatingsSum  sql.NullInt32  `db:"opp_ratings_sum"`
	NumWins        float32        `db:"num_wins"`
	IsLocked       bool           `db:"is_locked"`
	XID            string         `db:"x_id"`
	CreatedAt      time.Time      `db:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at"`
	ID_2           uuid.UUID      `db:"id_2"`
	Name           string         `db:"name"`
	ShortName      sql.NullString `db:"short_name"`
	StartDate      sql.NullTime   `db:"start_date"`
	EndDate        sql.NullTime   `db:"end_date"`
	State          uuid.UUID      `db:"state"`
	NumDivisions   sql.NullInt32  `db:"num_divisions"`
	NumRounds      sql.NullInt32  `db:"num_rounds"`
	NumEntries     sql.NullInt32  `db:"num_entries"`
	IsPc           bool           `db:"is_pc"`
	IsFc           bool           `db:"is_fc"`
	IsRr           bool           `db:"is_rr"`
	IsWespa        bool           `db:"is_wespa"`
	IsInvitational bool           `db:"is_invitational"`
	IsLocked_2     bool           `db:"is_locked_2"`
	CreatorID      uuid.NullUUID  `db:"creator_id"`
	OrganiserID    uuid.NullUUID  `db:"organiser_id"`
	DirectorID     uuid.NullUUID  `db:"director_id"`
	CoperatorID    uuid.NullUUID  `db:"coperator_id"`
	XID_2          string         `db:"x_id_2"`
	CreatedAt_2    time.Time      `db:"created_at_2"`
	UpdatedAt_2    time.Time      `db:"updated_at_2"`
}

func (q *Queries) ListRatingsTournaments(ctx context.Context, arg ListRatingsTournamentsParams) ([]ListRatingsTournamentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRatingsTournaments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRatingsTournamentsRow{}
	for rows.Next() {
		var i ListRatingsTournamentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TournamentID,
			&i.Division,
			&i.NumGames,
			&i.StartRating,
			&i.EndRating,
			&i.RatingPoints,
			&i.OppRatingsSum,
			&i.NumWins,
			&i.IsLocked,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.ShortName,
			&i.StartDate,
			&i.EndDate,
			&i.State,
			&i.NumDivisions,
			&i.NumRounds,
			&i.NumEntries,
			&i.IsPc,
			&i.IsFc,
			&i.IsRr,
			&i.IsWespa,
			&i.IsInvitational,
			&i.IsLocked_2,
			&i.CreatorID,
			&i.OrganiserID,
			&i.DirectorID,
			&i.CoperatorID,
			&i.XID_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentRatingsForPlayer = `-- name: ListRecentRatingsForPlayer :many
SELECT t.id, t.name, t.start_date, r.num_games, r.start_rating, r.end_rating, r.num_wins
FROM ratings r JOIN tournaments t ON r.tournament_id = t.id 
WHERE t.is_locked = true 
AND r.is_locked 
AND user_id = $1 
ORDER BY t.end_date DESC 
LIMIT 10
`

type ListRecentRatingsForPlayerRow struct {
	ID          uuid.UUID     `db:"id"`
	Name        string        `db:"name"`
	StartDate   sql.NullTime  `db:"start_date"`
	NumGames    sql.NullInt32 `db:"num_games"`
	StartRating sql.NullInt32 `db:"start_rating"`
	EndRating   sql.NullInt32 `db:"end_rating"`
	NumWins     float32       `db:"num_wins"`
}

func (q *Queries) ListRecentRatingsForPlayer(ctx context.Context, userID uuid.UUID) ([]ListRecentRatingsForPlayerRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentRatingsForPlayer, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentRatingsForPlayerRow{}
	for rows.Next() {
		var i ListRecentRatingsForPlayerRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StartDate,
			&i.NumGames,
			&i.StartRating,
			&i.EndRating,
			&i.NumWins,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentRatings = `-- name: ListTournamentRatings :many
SELECT r.id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, r.x_id, created_at, updated_at, u.id, first_name, last_name, alt_name, email, password_hash, absp_num, club_id, title_id, role_id, x_life, x_post, u.x_id, is_deceased, avatar, pw_token, pw_token_expiry FROM ratings r JOIN users u
ON r.user_id = u.id
WHERE r.tournament_id = $1 ORDER BY start_rating DESC
`

type ListTournamentRatingsRow struct {
	ID            uuid.UUID      `db:"id"`
	UserID        uuid.UUID      `db:"user_id"`
	TournamentID  uuid.UUID      `db:"tournament_id"`
	Division      int32          `db:"division"`
	NumGames      sql.NullInt32  `db:"num_games"`
	StartRating   sql.NullInt32  `db:"start_rating"`
	EndRating     sql.NullInt32  `db:"end_rating"`
	RatingPoints  sql.NullInt32  `db:"rating_points"`
	OppRatingsSum sql.NullInt32  `db:"opp_ratings_sum"`
	NumWins       float32        `db:"num_wins"`
	IsLocked      bool           `db:"is_locked"`
	XID           string         `db:"x_id"`
	CreatedAt     time.Time      `db:"created_at"`
	UpdatedAt     time.Time      `db:"updated_at"`
	ID_2          uuid.UUID      `db:"id_2"`
	FirstName     string         `db:"first_name"`
	LastName      string         `db:"last_name"`
	AltName       sql.NullString `db:"alt_name"`
	Email         sql.NullString `db:"email"`
	PasswordHash  sql.NullString `db:"password_hash"`
	AbspNum       sql.NullInt32  `db:"absp_num"`
	ClubID        uuid.NullUUID  `db:"club_id"`
	TitleID       uuid.NullUUID  `db:"title_id"`
	RoleID        uuid.UUID      `db:"role_id"`
	XLife         bool           `db:"x_life"`
	XPost         bool           `db:"x_post"`
	XID_2         string         `db:"x_id_2"`
	IsDeceased    bool           `db:"is_deceased"`
	Avatar        sql.NullString `db:"avatar"`
	PwToken       sql.NullString `db:"pw_token"`
	PwTokenExpiry sql.NullTime   `db:"pw_token_expiry"`
}

func (q *Queries) ListTournamentRatings(ctx context.Context, tournamentID uuid.UUID) ([]ListTournamentRatingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentRatings, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTournamentRatingsRow{}
	for rows.Next() {
		var i ListTournamentRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TournamentID,
			&i.Division,
			&i.NumGames,
			&i.StartRating,
			&i.EndRating,
			&i.RatingPoints,
			&i.OppRatingsSum,
			&i.NumWins,
			&i.IsLocked,
			&i.XID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.AltName,
			&i.Email,
			&i.PasswordHash,
			&i.AbspNum,
			&i.ClubID,
			&i.TitleID,
			&i.RoleID,
			&i.XLife,
			&i.XPost,
			&i.XID_2,
			&i.IsDeceased,
			&i.Avatar,
			&i.PwToken,
			&i.PwTokenExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateRatings = `-- name: TruncateRatings :exec
truncate ratings cascade
`

func (q *Queries) TruncateRatings(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, truncateRatings)
	return err
}

const updateRating = `-- name: UpdateRating :one
UPDATE ratings
SET
user_id = $2,
tournament_id = $3,
division = $4,
num_games = $5,
start_rating = $6,
end_rating = $7,
rating_points = $8,
opp_ratings_sum = $9,
num_wins = $10,
is_locked = $11,
x_id = $12
WHERE id = $1
RETURNING id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, x_id, created_at, updated_at
`

type UpdateRatingParams struct {
	ID            uuid.UUID     `db:"id"`
	UserID        uuid.UUID     `db:"user_id"`
	TournamentID  uuid.UUID     `db:"tournament_id"`
	Division      int32         `db:"division"`
	NumGames      sql.NullInt32 `db:"num_games"`
	StartRating   sql.NullInt32 `db:"start_rating"`
	EndRating     sql.NullInt32 `db:"end_rating"`
	RatingPoints  sql.NullInt32 `db:"rating_points"`
	OppRatingsSum sql.NullInt32 `db:"opp_ratings_sum"`
	NumWins       float32       `db:"num_wins"`
	IsLocked      bool          `db:"is_locked"`
	XID           string        `db:"x_id"`
}

func (q *Queries) UpdateRating(ctx context.Context, arg UpdateRatingParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, updateRating,
		arg.ID,
		arg.UserID,
		arg.TournamentID,
		arg.Division,
		arg.NumGames,
		arg.StartRating,
		arg.EndRating,
		arg.RatingPoints,
		arg.OppRatingsSum,
		arg.NumWins,
		arg.IsLocked,
		arg.XID,
	)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TournamentID,
		&i.Division,
		&i.NumGames,
		&i.StartRating,
		&i.EndRating,
		&i.RatingPoints,
		&i.OppRatingsSum,
		&i.NumWins,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRatingsNumWins = `-- name: UpdateRatingsNumWins :one
update ratings set num_wins = $3 where user_id = $1 and tournament_id = $2 returning id, user_id, tournament_id, division, num_games, start_rating, end_rating, rating_points, opp_ratings_sum, num_wins, is_locked, x_id, created_at, updated_at
`

type UpdateRatingsNumWinsParams struct {
	UserID       uuid.UUID `db:"user_id"`
	TournamentID uuid.UUID `db:"tournament_id"`
	NumWins      float32   `db:"num_wins"`
}

func (q *Queries) UpdateRatingsNumWins(ctx context.Context, arg UpdateRatingsNumWinsParams) (Rating, error) {
	row := q.db.QueryRowContext(ctx, updateRatingsNumWins, arg.UserID, arg.TournamentID, arg.NumWins)
	var i Rating
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TournamentID,
		&i.Division,
		&i.NumGames,
		&i.StartRating,
		&i.EndRating,
		&i.RatingPoints,
		&i.OppRatingsSum,
		&i.NumWins,
		&i.IsLocked,
		&i.XID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
